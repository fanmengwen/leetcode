## 区分树的深度和广度搜索

### 深度优先搜索 (DFS) - "一条路走到黑"

实现：用递归来实现 DFS

**什么时候用？**

当问题的答案与深度或者路径相关时，DFS 是首选。

- 经典遍历：前序、中序、后序遍历。它们的定义本身就是递归的。
  preOrder(node) = print(node.val) -> preOrder(node.left) -> preOrder(node.right)

- 寻找从根到叶子的路径：比如“找出所有从根到叶子路径总和等于给定值的路径”。DFS 能很自然地探索每一条完整的路径。

- 计算最大/最小深度：虽然 BFS 也能算最小深度，但用 DFS 计算最大深度非常直观。

- 验证树的属性：比如“判断一棵树是否是二叉搜索树”、“判断一棵树是否是平衡二叉树”。这类问题通常需要从上到下传递信息，或者从下到上汇总信息，递归的参数和返回值能很方便地处理这些。

### 广度优先搜索 (BFS) - "一层一层地扫"

像水波纹一样，从中心点（根节点）开始，先访问离它最近的一圈所有节点，然后再访问下一圈，以此类推，一层一层向外扩展。

实现：BFS 无法简单地用递归实现，因为它没有“回溯”的概念。它需要一个**队列（Queue）**来存储接下来要访问的节点，保证了“先来的（上一层的）先被访问”

**什么时候用？**
当问题的答案与层级或者最短路径相关时，BFS 是首选。

- 层序遍历：这是最经典的 BFS 应用，题目要求就是一层一层地输出。

- 寻找最短路径：在无权重的图中（树可以看作一种无环图），BFS 找到的第一个目标节点，其路径必然是最短的。因为它是一层一层找的，不可能先找到深度为 5 的目标，再找到深度为 3 的目标。

- 找到每一层的最右/最左侧节点。

## 二叉搜索树

1. 中序遍历是递增的，所以可以用来寻找最小值
